--- 
title: "Cookbook for R 中文版"
author: ["Winston Chang（著）", "王诗翔 等（译）"]
date: "`r Sys.Date()`"
documentclass: ctexbook
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
colorlinks: yes
lot: yes
lof: yes
geometry: [b5paper, tmargin=2.5cm, bmargin=2.5cm, lmargin=3.5cm, rmargin=2.5cm]
site: bookdown::bookdown_site
description: "Cookbook for R 中文版本"
github-repo:  openbiox/Cookbook-for-R-Chinese
#cover-image: images/cover.jpg
---

# 前言 {-}

Placeholder



<!--chapter:end:index.Rmd-->

# 作者简介 {#author .unnumbered}

Winston Chang <winston@stdout.org>

Winston is a software engineer at RStudio, and is a developer for the Shiny, ggplot2, and devtools packages. He holds a Ph.D. in psychology from Northwestern University and is the author of R Graphics Cookbook, published by O’Reilly Media.

Source: <https://resources.rstudio.com/authors/winston-chang>

<!--chapter:end:00-author.Rmd-->


# 基础 {#chapter1}

Placeholder


## 安装和使用 R 包 {#r-pkg-installation}
### 问题
### 方案
### 其他 {-}
## 数据结构的索引
### 问题
### 方案
#### 使用数字和名称进行索引
#### 使用布尔向量进行索引
#### 负索引
## 获取数据结构的子集
### 问题
### 方案
## 创建填满值的向量
### 问题
### 方案
## 变量信息
### 问题
### 方案
#### 关于存在的信息
#### 关于大小/结构的信息
## NULL、NA、NaN 的处理
### 问题
### 方案
#### 忽视向量汇总函数中的「坏」值
#### 从向量中移除「坏值」
#### 注意

<!--chapter:end:01-basics.Rmd-->


# 数字

Placeholder


## 生成随机数
### 问题
### 方案
### 注意
## 生成可重复的随机序列 
### 问题
### 方案
## 保持随机数生成器的状态
### 问题
### 方案
#### 在函数中保存和恢复随机数生成器的状态
#### 注意
## 对数值取整
### 问题
### 方案
## 比较浮点数
### 问题
### 方案

<!--chapter:end:02-numbers.Rmd-->


# 字符串

Placeholder


## 使用 grep、sub、gsub 进行搜索和替换
### 问题
### 方案
#### 文本搜索
#### 文本替换
## 通过变量创建字符串
### 问题
### 方案
#### 使用 paste()
#### 使用 sprintf()
#### 注意

<!--chapter:end:03-strings.Rmd-->


# 公式

Placeholder


## 通过字符串创建公式
### 问题
### 方案
## 从公式中提取组分
### 问题
### 方案

<!--chapter:end:04-formulas.Rmd-->


# 数据的导入与导出

Placeholder


## R载入文件中的数据 {#r-import-data-from-file}
### 问题
### 方案
#### 带分隔符的文本文件
#### 打开文件的文件选择器
#### 把字符串看作因子（factor）或字符（character）
#### 从网上导入文件
#### 定宽文本文件
#### Excel 文件
#### SPSS 数据
## 通过键盘和剪贴板把数据载入并保存到 R {#read-data-from-keyboard}
### 问题
### 方案
#### 数据输入
##### 通过键盘输入或从剪贴板载入数据
##### 在脚本中载入数据
#### 数据输出
##### 写入可以复制粘贴或粘贴到剪贴板的数据
##### 输出 R 中的载入数据
## 运行 R 脚本 {#run-r-script}
### 问题
### 方案
## 用 R 把数据写入文件 {#r-write-data-into-file}
### 问题
### 方案
#### 写到有分隔符的文本文件
#### 以 R 的数据格式保存
## 用 R 写入文本，分析输出到文件 {#r-output-analysis}
### 问题
### 方案

<!--chapter:end:05-io.Rmd-->


# 数据操作

Placeholder


## 排序
### 问题
### 方案
#### 向量
#### 列表
##### 反向排序
## 随机排序
### 问题
### 方案
#### 注意
## 转换向量类型
### 问题
### 方案
## 查找并移除重复记录
### 问题
### 方案
#### 向量
#### 列表
## NA 存在时进行向量或因子比较 {#compare-with-nas}
### 问题
### 方案
#### 可以与 `NA` 相比的函数
#### 使用该函数的例子
## 数据重新编码
### 问题
### 方案
#### 重新编码分类变量
#### 将一个连续变量重编码为分类变量
#### 计算得到一个新的连续变量
## 映射向量值
### 问题
### 方案
## 重命名因子水平
### 问题
### 方案
### 更多参考
## 重计算因子水平
### 问题
### 方案
### 另见
## 改变因子水平次序
### 问题
### 方案
## 重命名数据框的列
### 问题
### 方案
## 添加和移除数据框的列
### 问题
### 方案
## 对数据框的列重新排序
### 问题
### 方案
## 合并数据框
### 问题
### 方案
### 注意
## 比较数据框
### 问题
### 方案
#### 一个例子
#### 连接数据框
#### dupsBetweenGroups 函数
#### 寻找重复行
#### 寻找唯一行
#### 拆分数据框
#### 忽略列
### 注意
## 重计算数据框所有因子列的水平
### 问题
### 方案
#### 使用 `droplevels`
#### 使用 `vapply` 和 `lapply`
### 另见
## 长宽格式数据互换
### 问题
### 方案
#### 样例数据
#### tidyr
##### 从宽格式到长格式
##### 从长格式到宽格式
#### reshape2
##### 从宽格式到长格式
##### 从长格式到宽格式
## 汇总数据
### 问题
### 方案
#### 使用 ddply
##### 处理缺失值
##### 自动汇总函数
##### 用零填满空组合
#### 使用summaryBy
##### 处理缺失值
##### 自动汇总函数
##### 用零填满空组合
#### 使用 aggregate
## 数据框与列联表互换
### 问题
### 方案
#### 将情况记录转为列联表
#### 将情况记录转为计数
#### `countsToCases()` 函数
#### 列联表转为情况记录
#### 列联表转为计数
#### 计数转为情况记录
#### 计数转为列联表
## 计算移动平均数
### 问题
### 解决方案
## 窗口平滑
### 问题
### 方案
## 寻找唯一值序列
### 问题
### 方案
### 处理因子
## 用最后一个非 NA 值填充 NA {#fill-na-with-last-value}
### 问题
### 方案
#### 填充 NA 的函数
#### 注释

<!--chapter:end:06-manipulation.Rmd-->


# 统计分析

Placeholder


## 回归和相关分析
### 问题
### 方案
#### 相关系数
#### 相关矩阵（多个变量）
#### 线性回归
#### 多个预测变量的线性回归（多元线性回归）
##### 交互效应
## t 检验
### 问题
### 方案
#### 样本数据
#### 比较两组：独立双样本t检验
#### 配对样本t检验
#### 与期望的总体均值进行比较：单样本 t 检验
## 频率检验
### 问题
### 方案
#### 拟合优度检验 （期望频率）
##### 卡方检验
##### 精确二项检验
#### 独立检验（比较组间）
##### 卡方检验
##### Fisher 精确检验
##### Cochran-Mantel-Haenszel test
#### McNemar 检验
## ANOVA
### 问题
### 方案
#### 单因素 ANOVA 分析
#### 双因素 ANOVA 分析
#### Tukey HSD post-hoc 检验
### 有受试内变量的 ANOVAs
#### One-way within ANOVA
#### 混合设计 ANOVA
#### 更多被试内变量的 ANOVA
## 逻辑回归
### 问题
### 方案
#### 连续预测变量，离散响应变量
##### 画图
#### 离散预测变量，离散响应变量
##### 画图
#### 连续和离散预测变量，离散响应变量
#### 有交互项的多个预测变量
## 变量同质性
### 问题
### 方案
#### 样例数据
#### Bartlett’s test
#### Levene’s test
#### Fligner-Killeen test

<!--chapter:end:07-stats.Rmd-->


# 标准绘图

Placeholder


## 直方图和密度图
### 问题
### 方案
#### 多个组别的核密度图
## 散点图
### 问题
### 方案
#### 基本的散点图
#### 散点图矩阵
## 箱线图
### 问题
### 方案
## QQ 图 {#qq-plot}
### 问题
### 方案

<!--chapter:end:08-graphs-baseplot.Rmd-->


# ggplot2

Placeholder


## 条形图与线图
### 问题
### 方案
#### 基本图形，离散 x-axis
##### 有值的条形图
##### 计数的条形图
#### 线图
### 有更多变量的图
#### 条形图
#### 线图
#### 完成的例子
### 使用数值 x-axis
#### x-axis 作为连续变量
#### x-axis 作为分类变量
## 绘制均值和误差线
### 问题
### 方案
#### 助手函数
#### 示例数据
#### 线图
#### 条形图
#### 为组内变量添加误差线
#### 理解组内变量的误差线
#### 两个组内变量
### 注意标准化的均值
### 其他
## 分布图
### 问题
### 方案
#### 直方图和概率密度图
#### 多组数据的直方图和概率密度图
#### 箱型图
## 散点图
### 问题	
### 方案
#### 带回归线的基本散点图
#### 通过其他变量设置颜色和形状
#### 处理图像元素叠加
## 标题
### 问题
### 方案
## 坐标轴 {#ggplot2-axes}
### 问题
### 方案
#### 交换 x 和 y 轴
#### 离散轴
##### 改变条目的顺序
##### 设定标签
#### 连续轴
##### 设定范围和反转轴方向
##### 反转轴方向
##### 设置和隐藏刻度标记
##### 轴刻度 log、sqrt 等转换
##### x 与 y 轴固定的比例
#### 轴标签和文字格式化
#### 刻度标签
#### 隐藏网格线
## 图例 {#ggplot2-legends}
### 问题
### 方案
#### 去除图例
#### 在图例中改变变量的顺序
#### 反转图例中的条目顺序
#### 隐藏图例标题
#### 修改图例标题和标签的文字
##### 使用比例尺
##### 使用填充和颜色
##### 比例尺的种类
#### 更改数据框中的因子
#### 修改图例标题和标签的外观
#### 修改图例框
#### 改变图例位置
#### 隐藏在图例中的斜线
### 注意
## 线条
### 问题
### 方案
#### 使用一个连续轴和一个分类轴
##### 一条线段
##### 每个分类值的单独行
##### 分组栏上的线条
#### 各个组合柱状图上的线条
#### 有两个连续轴
##### 基础线条
##### 画线为平均值
##### 在分面使用线条
## 分面 {#ggplot-facet}
### 问题
### 方案
#### 样本数据
#### facet_grid
#### facet_wrap
#### 修改分面标签的外观
#### 修改分面标签的文本
#### 设置标度
## 多图
### 问题
### 方案
## 颜色 {#ggplot2-colors}
### 问题
### 方案
#### 样本数据
#### 简单的颜色设置
#### 将变量值映射到颜色
#### 对色盲友好的颜色 {#colorblind-friendly}
#### 颜色选择
#### 设置亮度和饱和度（色度）
#### 调色板：Color Brewer
#### 调色板：手动定义
#### 连续颜色
#### 比色图表
#### 十六进制色码图
#### RColorBrewer 调色板图表

<!--chapter:end:09-graphs-ggplot2.Rmd-->


# 图形混杂

Placeholder


## 输出到文件 PDF-PNG-TIFF-SVG
### 问题
### 方案
#### PDF格式
#### SVG 格式
#### PNG/TIFF格式
#### 对于不支持 PDF 格式的程序 （MS Office）
#### ggplot2
#### 保存屏幕中的图像
## 形状和线形 {#shape-and-linetype}
### 问题
### 方案
#### 标准图形
#### ggplot2
#### 附录
## 字体
### 问题
### 方案
#### geom_text
#### themes and element_text
#### 字体表格
## 抗混淆位图输出
### 问题
### 方案
#### 提示

<!--chapter:end:10-graphs-misc.Rmd-->


# 其他有趣图形

Placeholder


## 相关矩阵 {#corr-mat}
### 问题
### 方案
#### 提示

<!--chapter:end:11-graphs-other.Rmd-->

# 脚本与函数

```{r, include=F}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## 创建和运行一个脚本

### 问题

你想要创建和运行一个脚本。

### 方案

R 脚本通常是以 `.R` 为文件拓展名的纯文本文件。因此创建R脚本可以是任意的文本编辑器，R 最佳的集成开发环境是 [RStudio](https://www.rstudio.com/)，它开源并有免费的桌面版本和服务器版本发布，推荐读者下载、安装和使用。

在类 Unix 系统中，除了编辑器，我们还可以使用终端命令。例如，创建一个输出 `Hello world!` 的 R 脚本。

```{bash}
echo 'cat("Hello world!")' > test.R
```

运行 R 脚本可以在 R 控制台使用 `source()`函数。

```{r}
source("test.R", print.eval = TRUE)
```

也可以在终端中使用 `RScript` 执行。

```{bash}
RScript test.R
```



### 案例：计算细菌基因组核心蛋白相似性

- 应用场景

  细菌分类学研究中，需要借助基因组水平的相似度来界定是否属于新物种，是否是一个未发现的新属水平或者新科水平，乃至更高的分类学单元（界/门/纲/目/科/属/种）。

  在基因组的核酸水平研究中，有诸如 dDDH（数字化 DNA 分子杂交）、核苷酸平均相似度（Average Nucleotide Identity，ANI）等指标来界定是否属于新物种；而在基因组蛋白质水平相类似的指标较少，比如氨基酸平均相似度（Average Amino acid Identity，AAI）和保守蛋白比率（percentage of conserved proteins，POCP）等。

- 简要过程

  两两比对细菌基因组的蛋白序列，互为参考数据库进行 blastp 比对（A 作数据库，B 查询；B 作数据库，A 查询），数据筛选的标准是：一致度大于 40%，查询片段的长度大于原片段长度的 50%，e 值小于 1e-5。

- 参考文献

  Qin, Q. L., Xie, B. B., Zhang, X. Y., Chen, X. L., Zhou, B. C., Zhou, J., ... & Zhang, Y. Z. (2014). A proposed genus boundary for the prokaryotes based on genomic insights. Journal of bacteriology, 196(12), 2210-2215.


**以下 R 脚本都是在 windows 操作平台上进行的**

```r
# 下载所分析的基因组数据（蛋白序列）
# 存放于 Rawdata 文件夹中
if (!dir.exists('Rawdata')) {
  dir.create('Rawdata')
}

# 示例-1: Pseudomonas aeruginosa
# ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/006/765/GCF_000006765.1_ASM676v1/GCF_000006765.1_ASM676v1_protein.faa.gz

# 示例-2: Acinetobacter baumannii
# ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/746/645/GCF_000746645.1_ASM74664v1/GCF_000746645.1_ASM74664v1_protein.faa.gz

# 使用 R.utils 中的 gunzip 解压缩
library(R.utils)

download.file("ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/006/765/GCF_000006765.1_ASM676v1/GCF_000006765.1_ASM676v1_protein.faa.gz",
              destfile = "Rawdata/Pseudomonas_aeruginosa.faa.gz")
gunzip("Rawdata/Pseudomonas_aeruginosa.faa.gz")

download.file("ftp://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/746/645/GCF_000746645.1_ASM74664v1/GCF_000746645.1_ASM74664v1_protein.faa.gz",
              destfile = "Rawdata/Acinetobacter_baumannii.faa.gz")
gunzip("Rawdata/Acinetobacter_baumannii.faa.gz")
```

```R
# 使用 dbplyr 对数据框中的某列去重复
library(dbplyr)
# 使用 seqinr 格式化 fasta 格式的序列
library(seqinr)

# 检查存放中间过程文件的文件夹是否存在
if (!dir.exists('Database')) {
  dir.create('Database')
}

if (!dir.exists('Result')) {
  dir.create('Result')
}

# 获取所有待分析基因组文件名
genome.files <- list.files('Rawdata')

# 对所有的待分析基因组建库
for (gn in genome.files) {
  header.file <- strsplit(gn,'.',fixed = T)[[1]][1]
  commond.makedb <- paste0('diamond.exe makedb --in Rawdata/',
                           gn, ' --db Database/', header.file)
  system(commond.makedb)
}

# 获取多基因组的两两比对的组合数据集
genome.comn <- combn(genome.files,2)

# 计算核心蛋白相似性的骨架命令
blast.comm1 <- 'diamond.exe blastp -q Rawdata/'
blast.comm2 <- ' -d Database/'
blast.comm3 <- ' -e 1e-5 --id 40 -o Result/'

# 建立新变量，保存运算结果
pocp.vector <- c()

for (i in (1:dim(genome.comn)[2]) ) {
  a.genome <- genome.comn[,i][1]
  b.genome <- genome.comn[,i][2]

  a.header <- strsplit(a.genome,'.',fixed = T)[[1]][1]
  b.header <- strsplit(b.genome,'.',fixed = T)[[1]][1]

  a.genome.seq <- read.fasta(paste0('Rawdata/', a.genome),'AA')
  b.genome.seq <- read.fasta(paste0('Rawdata/', b.genome),'AA')

  a.total <- length(a.genome.seq)
  b.total <- length(b.genome.seq)

  str(a.genome.seq)
  str(b.genome.seq)

  a.seq.list <- names(a.genome.seq)
  b.seq.list <- names(b.genome.seq)
  a.seq.length <- c()

  for (nm in a.seq.list) {
    tmp.len <- length(a.genome.seq[[which(a.seq.list == nm)]])
    a.seq.length <- append(a.seq.length, tmp.len)
  }
  b.seq.length <- c()

  for (nm in b.seq.list) {
    tmp.len <- length(b.genome.seq[[which(b.seq.list == nm)]])
    b.seq.length <- append(b.seq.length, tmp.len)
  }

  a.seq.df <- data.frame(a.seq.list, a.seq.length)
  colnames(a.seq.df) <- c('V1','length')
  b.seq.df <- data.frame(b.seq.list, b.seq.length)
  colnames(b.seq.df) <- c('V1','length')

  print(paste0('-- Blasting: ',a.header,' - VS - ',b.header))

  # 「正向」-- A 为查询，B 为参考数据库
  result.forward <- paste0(a.header,'_VS_',b.header,'.tab')
  system(paste0(blast.comm1, a.genome,
                blast.comm2, b.header,
                blast.comm3, result.forward))
  df.forward <- read.table(paste0('Result/',result.forward),
                           header = F,sep = '\t',
                           stringsAsFactors = F)
  df.forward <- df.forward  %>%  distinct(V1,.keep_all = T)
  df.forward <- merge(df.forward, a.seq.df, by = 'V1', all.x = T)
  df.forward$align <- df.forward$V4 / df.forward$length
  df.forward <- df.forward[which(df.forward$V3 > 40 & df.forward$align > 0.5 & df.forward$V11 < 1e-5),]
  C1 <- dim(df.forward)[1]

  # 「反向」-- B 为查询，A 为参考数据库
  result.backward <- paste0(b.header,'_VS_',a.header,'.tab')
  system(paste0(blast.comm1, b.genome,
                blast.comm2, a.header,
                blast.comm3, result.backward))
  df.backward <- read.table(paste0('Result/',result.backward),
                           header = F,sep = '\t',
                           stringsAsFactors = F)
  df.backward <- df.backward %>% distinct(V1,.keep_all = T)
  df.backward <- merge(df.backward, b.seq.df, by = 'V1', all.x = T)
  df.backward$align <- df.backward$V4 / df.backward$length
  df.backward <- df.backward[which(df.backward$V3 > 40 & df.backward$align > 0.5 & df.backward$V11 < 1e-5),]
  C2 <- dim(df.backward)[1]

  pocp <- (C1 + C2)/(a.total + b.total)
  pocp.vector <- append(pocp.vector, paste0(a.header,'\t',b.header,'\t',pocp))

  print(paste0('-- Pair blast done: ',a.header,' - VS - ',b.header))
  print(paste0('-- The POCP : ', pocp))
  print('----------------------------------')
}

write(pocp.vector, 'resultPOCP.txt')

# 删除分析过程中的冗余文件
unlink("Database", recursive = TRUE)
unlink("Result", recursive = TRUE)

# 重新创建新文件夹
dir.create('Database')
dir.create('Result')
```

#### 提示

更多关于 POCP 计算的相关技巧，请点击[这里阅读](https://github.com/2015qyliang/POCP)。

## 调试脚本或函数

### 问题

您想要调试脚本或函数。

### 方案

将其插入您要开始调试的位置的代码中：

```r
browser()
```

当 R 解释器到达该行时，它将暂停你的代码，您将能够查看和更改变量。

在控制台中，键入这些字母将执行以下操作
	
|c  | 继续 |
| :------------- | :------------- |
| **n (or Return)** |  **下一步** |
| **Q** | **放弃** |
| **Ctrl-C** | **回到顶级**|

在控制台中，你可以看到当前范围中的变量。

```r
ls()
```

要为函数中的每一行暂停和启动浏览器

```r
debug(myfunction)
myfunction(x)
```
### 有用的选项

默认情况下，每次在提示符下按 Enter 键，它都会运行下一步。这相当于按 n，然后按 Enter 键。这可能很烦人。要禁用它，请使用：

```r
options(browserNLdisabled=TRUE)
```

要在抛出错误时开始调试，请在抛出错误的函数之前运行此命令

```r
options(error=recover)
```

如果你希望每次启动R时都设置这些选项，则可以将它们放在 `~/.Rprofile` 文件中。


## 测量运行的时间

### 问题

您想要测量运行特定代码块所需的时间。

### 方案

`system.time()` 函数将测量在 R 中运行某些东西所需的时间。

```{r}
tm <- system.time({
    # 做一些消耗时间的事情
    x <- 1:100000
    for (i in seq_along(x))  x[i] <- x[i]+1
})
tm
```

输出显示运行代码块需要 `r tm[1]` 秒。

## 获取包中的函数和对象列表

### 问题

你想知道包里有什么。

### 方案

在一个新的 R 会话中使用 `search()` 可以查看默认加载的包。

```{r}
search()
```

以下提供的函数能够列出包中的函数和对象。

```{r}
showPackageContents <- function (packageName) {

    # 获取特定包所有内容的列表
    funlist <- objects(packageName)

    # 移除不以字母开头的东西
    idx <- grep('^[a-zA-Z][a-zA-Z0-9._]*', funlist)
    funlist <- funlist[idx]

    # 移除包含箭头 <- 的东西
    idx <- grep('<-', funlist)
    if (length(idx)!=0)
        funlist <- funlist[-idx]

    # 创建一个数据框保存数据
    objectlist <- data.frame(name=funlist,
                             primitive=FALSE,
                             func=FALSE,
                             object=FALSE,
                             constant=FALSE,
                             stringsAsFactors=F)

    for (i in 1:nrow(objectlist)) {
        fname <- objectlist$name[i]
        if (exists(fname)) {
            obj <- get(fname)
            if (is.primitive(obj)) {
                objectlist$primitive[i] <- TRUE
            }
            if (is.function(obj)) {
                objectlist$func[i] <- TRUE
            }
            if (is.object(obj)) {
                objectlist$object[i] <- TRUE
            }
            
            # 我认为这些基本是常量
            if (is.vector(obj)) {
                objectlist$constant[i] <- TRUE
            }
           
        
        }  
    }

    cat(packageName)
        
    cat("\n================================================\n")
    cat("Primitive functions: \n")
    cat(objectlist$name[objectlist$primitive])
    cat("\n")

    cat("\n================================================\n")
    cat("Non-primitive functions: \n")
    cat(objectlist$name[objectlist$func  &  !objectlist$primitive])
    cat("\n")

    cat("\n================================================\n")
    cat("Constants: \n")
    cat(objectlist$name[objectlist$constant])
    cat("\n")

    cat("\n================================================\n")
    cat("Objects: \n")
    cat(objectlist$name[objectlist$object])
    cat("\n")
}

```

以 **base** 包作为示例测试：

```{r}
showPackageContents("package:base")
```

```{r, include=FALSE}
detachAllPackages()
```

<!--chapter:end:12-scripts-and-funs.Rmd-->


# 工具

Placeholder


## 生成拉丁方
### 问题
### 方案
#### 生成拉丁方的函数
#### 检查函数的随机性

<!--chapter:end:13-tools.Rmd-->

\cleardoublepage 

# (APPENDIX) 附录 {-}

# 资料推荐 {#materials}

## 书籍

- [《R for Data Science》](https://r4ds.had.co.nz/index.html)

## 网站

## 列表


<!--chapter:end:14-append.Rmd-->

`r if (knitr:::is_html_output()) '# 参考文献 {#references .unnumbered}'`

```{r include=FALSE}
# 自动生成 R 包的参考文献
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown'
), 'packages.bib')
```


<!--chapter:end:15-references.Rmd-->

